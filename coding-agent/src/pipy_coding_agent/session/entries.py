"""Session entry types for persistence.

Sessions are stored as append-only JSONL files with a tree structure.
Each entry has an id and parentId forming a DAG, allowing branching
without modifying history.
"""

from datetime import datetime
from typing import Any, Literal, TypedDict

from pipy_agent import AgentMessage


# Session version for migrations
CURRENT_SESSION_VERSION = 3


class SessionHeader(TypedDict):
    """Session file header - first line of JSONL file."""

    type: Literal["session"]
    version: int
    id: str
    timestamp: str
    cwd: str
    parentSession: str | None  # Path to parent session if forked


class SessionEntryBase(TypedDict):
    """Base fields for all session entries."""

    type: str
    id: str
    parentId: str | None
    timestamp: str


class SessionMessageEntry(SessionEntryBase):
    """A message in the conversation."""

    type: Literal["message"]
    message: AgentMessage


class ThinkingLevelChangeEntry(SessionEntryBase):
    """Record of thinking level change."""

    type: Literal["thinking_level_change"]
    thinkingLevel: str


class ModelChangeEntry(SessionEntryBase):
    """Record of model change."""

    type: Literal["model_change"]
    provider: str
    modelId: str


class CompactionEntry(SessionEntryBase):
    """Summary from context compaction."""

    type: Literal["compaction"]
    summary: str
    firstKeptEntryId: str
    tokensBefore: int
    details: Any | None  # Extension-specific data
    fromHook: bool | None  # True if generated by extension


class BranchSummaryEntry(SessionEntryBase):
    """Summary when navigating back from a branch."""

    type: Literal["branch_summary"]
    fromId: str
    summary: str
    details: Any | None
    fromHook: bool | None


class CustomEntry(SessionEntryBase):
    """Extension-specific data (not sent to LLM)."""

    type: Literal["custom"]
    customType: str
    data: Any | None


class CustomMessageEntry(SessionEntryBase):
    """Extension message that participates in LLM context."""

    type: Literal["custom_message"]
    customType: str
    content: str | list[dict]  # TextContent | ImageContent
    display: bool
    details: Any | None


class LabelEntry(SessionEntryBase):
    """User-defined bookmark/marker on an entry."""

    type: Literal["label"]
    targetId: str
    label: str | None


class SessionInfoEntry(SessionEntryBase):
    """Session metadata (e.g., display name)."""

    type: Literal["session_info"]
    name: str | None


# Union of all session entry types
SessionEntry = (
    SessionMessageEntry
    | ThinkingLevelChangeEntry
    | ModelChangeEntry
    | CompactionEntry
    | BranchSummaryEntry
    | CustomEntry
    | CustomMessageEntry
    | LabelEntry
    | SessionInfoEntry
)

# Union including header
FileEntry = SessionHeader | SessionEntry


# Message prefixes for LLM context
COMPACTION_SUMMARY_PREFIX = """The conversation history before this point was compacted into the following summary:

<summary>
"""

COMPACTION_SUMMARY_SUFFIX = """
</summary>"""

BRANCH_SUMMARY_PREFIX = """The following is a summary of a branch that this conversation came back from:

<summary>
"""

BRANCH_SUMMARY_SUFFIX = "</summary>"


def generate_id(existing_ids: set[str]) -> str:
    """Generate a unique short ID (8 hex chars)."""
    import uuid

    for _ in range(100):
        new_id = uuid.uuid4().hex[:8]
        if new_id not in existing_ids:
            return new_id
    # Fallback to full UUID
    return uuid.uuid4().hex


def now_iso() -> str:
    """Get current timestamp in ISO format."""
    from datetime import timezone
    return datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")


def create_message_entry(
    message: AgentMessage,
    parent_id: str | None,
    existing_ids: set[str],
) -> SessionMessageEntry:
    """Create a message entry."""
    return SessionMessageEntry(
        type="message",
        id=generate_id(existing_ids),
        parentId=parent_id,
        timestamp=now_iso(),
        message=message,
    )


def create_thinking_level_entry(
    thinking_level: str,
    parent_id: str | None,
    existing_ids: set[str],
) -> ThinkingLevelChangeEntry:
    """Create a thinking level change entry."""
    return ThinkingLevelChangeEntry(
        type="thinking_level_change",
        id=generate_id(existing_ids),
        parentId=parent_id,
        timestamp=now_iso(),
        thinkingLevel=thinking_level,
    )


def create_model_change_entry(
    provider: str,
    model_id: str,
    parent_id: str | None,
    existing_ids: set[str],
) -> ModelChangeEntry:
    """Create a model change entry."""
    return ModelChangeEntry(
        type="model_change",
        id=generate_id(existing_ids),
        parentId=parent_id,
        timestamp=now_iso(),
        provider=provider,
        modelId=model_id,
    )


def create_compaction_entry(
    summary: str,
    first_kept_entry_id: str,
    tokens_before: int,
    parent_id: str | None,
    existing_ids: set[str],
    details: Any = None,
    from_hook: bool = False,
) -> CompactionEntry:
    """Create a compaction entry."""
    return CompactionEntry(
        type="compaction",
        id=generate_id(existing_ids),
        parentId=parent_id,
        timestamp=now_iso(),
        summary=summary,
        firstKeptEntryId=first_kept_entry_id,
        tokensBefore=tokens_before,
        details=details,
        fromHook=from_hook if from_hook else None,
    )


def create_custom_entry(
    custom_type: str,
    data: Any,
    parent_id: str | None,
    existing_ids: set[str],
) -> CustomEntry:
    """Create a custom entry for extensions."""
    return CustomEntry(
        type="custom",
        id=generate_id(existing_ids),
        parentId=parent_id,
        timestamp=now_iso(),
        customType=custom_type,
        data=data,
    )


def create_custom_message_entry(
    custom_type: str,
    content: str | list[dict],
    display: bool,
    parent_id: str | None,
    existing_ids: set[str],
    details: Any = None,
) -> CustomMessageEntry:
    """Create a custom message entry for LLM context."""
    return CustomMessageEntry(
        type="custom_message",
        id=generate_id(existing_ids),
        parentId=parent_id,
        timestamp=now_iso(),
        customType=custom_type,
        content=content,
        display=display,
        details=details,
    )


def create_session_info_entry(
    name: str,
    parent_id: str | None,
    existing_ids: set[str],
) -> SessionInfoEntry:
    """Create a session info entry."""
    return SessionInfoEntry(
        type="session_info",
        id=generate_id(existing_ids),
        parentId=parent_id,
        timestamp=now_iso(),
        name=name.strip() if name else None,
    )
